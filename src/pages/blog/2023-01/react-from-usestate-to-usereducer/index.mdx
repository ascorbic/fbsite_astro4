---
layout: ../../../../layouts/BlogPageLayout.astro
slug: '2023-01/react-from-usestate-to-usereducer'
title: React | from useState to useReducer
title1: React 
title2: From <code>useState</code> hook to <code>useReducer</code> 
description: How to migrate your code from multiple "useState" hooks to one "useReducer" 
author: ['Fabio Biondi']
image: 
  blur: "image.png"
  url: "image.png"
  alt: "react emote"
pubDate: 2022-12-30
tags: ["react", "typescript"] 
series: 
  name: "React Tips"
difficulty: 1
draft: false
---

import * as W from '@widgets';
import StackBlitz from '@widgets/StackBlitz'; // NOTE: cannot be exported from barrel file 

# Introduction

The React `useReducer` hook is one of the less used and under rated built-in hook but it can be especially useful when we use several `useState` hooks in a component that are related to each other.

<W.Hint type="empty" title="TypeScript and 'useReducer'">

Many authors have written a lot of interesting articles about this topic and I suggest you to read the Kent C. Dodds post "[Should I useState or useReducer?](https://kentcdodds.com/blog/should-i-usestate-or-usereducer) "  to get more info about it.
You can also find a lot of info in the [React Beta Documentation](https://beta.reactjs.org/reference/react/useReducer) too.

However these tutorials are often written by using React and JavaScript so I wrote this post as introduction for another article about `useReducer` and `TypeScript`: 

[React 18.x & TypeScript | How to safely type the useReducer hook](./how-to-safely-type-usereducer-in-react-and-typescript)

</W.Hint>


# Topics

# multiple `useState` hooks

Let's imagine that we have to create a simple React component that needs to fetch data from a REST API, show a loading message and display an error if the HTTP request fails.

Furthermore we also want to remove an user from the list, always handling errors and loading messages.

<W.Img isWindowed={false} src={import('./images/2022-12-31_00-02-55 (1).gif')} w={600} quality={60} border/>


The first example uses 3 different `useState` to handle all the info we need to control the User Interface :

* `users` (Array): store all data fetched from a REST API (a list of users);
* `pending` (Boolean): used to display a loading message. This state is set to `true` when a new request is done and to `false` when the request completes or fails;
* `error` (Boolean): used to display an error message. It's `true` when the request fails, otherwise must be `false`.


<W.Hint title="TIP">
  There are better solutions to fetch and handle data in React application. You can use [Tantask](https://tanstack.com/) (aka React Query), the latest version of [React Router](https://reactrouter.com/) and many other techniques.
  Anyway in this article I would like us to focus on differences between `useState` and `useReducer`
</W.Hint>

Here the full example: read the comments I wrote into the snippet to understand how it works:

<W.Code techs={['react', 'js']}>
```typescript
import axios from 'axios';
import React, { useEffect, useState } from 'react';

export const Demo1MultipleUseState = () => {
  // state initialization
  const [users, setUsers] = useState([]);
  const [pending, setPending] = useState(false);
  const [error, setError] = useState(false);

  // when the component is mount
  useEffect(() => {
    // set the pending state
    setPending(true);
    // fetch data from a REST API
    axios
      .get('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        // success: 
        setUsers(res.data); // save the response in "users" state
        setPending(false);  // remove pending message
        setError(false);    // remove any previous errors
      })
      .catch((e) => {
        setError(true);     // set error
        setPending(false);  // remove pending
      });
  }, []);

  function deleteHandler(id) {
    setPending(true);
    // remove the element invoking the endpoint
    axios
      .delete(`https://jsonplaceholder.typicode.com/users/${id}`)
      .then((res) => {
        // remove the element from the array
        setUsers((s) => s.filter((u) => u.id !== id));
        setError(false);
        setPending(false);
      })
      .catch((e) => {
        setError(true);
        setPending(false);
      });
  }

  return (
    <div>
      <h1>1. Multiple useState Demo</h1>

      {pending && <div>loading...</div>}
      {error && <div>some errors</div>}

      <ul>
        {users.map((u) => (
          <li key={u.id}>
            {u.name}
            <button onClick={() => deleteHandler(u.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```
</W.Code>

<W.Hint title="several useState and performance">
  The previous snippet would have generated multiple component renders before React 18 since we have set multiple `useState` at the same time after an async operation.
  
  But that's not a problem anymore since now multiple `useState` operations are batched.
</W.Hint>

<StackBlitz clickToLoad={false} url="https://stackblitz.com/edit/react-mz8fza?devToolsHeight=33&file=src/examples/Demo1MultipleUseState.jsx" client:visible/>



# Move to one `useState` only

The previous snippet works fine but the code becomes less and less readable as the number of `useHooks` increases and are related each other.

So we can replace all states with just one `useState` by using an object so structured:

<W.Code techs={['react', 'js']}>
```ts
{ 
  users: [], 
  pending: false, 
  error: false 
};
```
</W.Code>

Now we can update the snippet as shown below. Read the comment for more info:


<W.Code techs={['react', 'js']}>
```typescript
import axios from 'axios';
import React, { useEffect, useState } from 'react';

// NEW: state initialization
const initialState = { users: [], pending: false, error: false };

export const Demo2UniqueUseState = () => {
  // UPDATE: we have just one useState now 
  const [data, setData] = useState(initialState);

  useEffect(() => {
    // UPDATE: set "pending" value
    setData((s) => ({ ...s, pending: true }));

    axios
      .get('https://jsonplaceholder.typicode.com/users')
      .then((res) => {
        // UPDATE: now we use just one useState to update all properties
        // to populate "users" and set both, "error" and "pending"
        setData((s) => ({
          users: s.users.filter((u) => u.id !== id),
          error: false,
          pending: false,
        }));
        
      })
      .catch((e) => {
        // UPDATE: update error and pending properties
        setData((s) => ({ ...s, error: true, pending: false }));
      });
  }, []);

  function deleteHandler(id) {
    setData((s) => ({ ...s, pending: true }));
    axios
      .delete(`https://jsonplaceholder.typicode.com/users/${id}`)
      .then((res) => {
        setData((s) => ({
          ...s,
          users: s.filter((u) => u.id !== id),
          pending: false,
        }));
      })
      .catch((e) => {
        setData((s) => ({ ...s, error: true, pending: false }));
      });
  }

  return (
    <div>
      <h1>2. Unique useState Demo</h1>

      {data.pending && <div>loading...</div>}
      {data.error && <div>some errors</div>}

      <ul>
        {data.users.map((u) => (
          <li key={u.id}>
            {u.name}
            <button onClick={() => deleteHandler(u.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

```
</W.Code>

<W.Hint title="Tip: Spread operator">
  What is this syntax? 

  <W.Code techs={['react', 'js']}>
  ```js
  ✅ { ...s, pending: true }
  ```
  </W.Code>

  The three dots `...` is known as [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)
   and it's used to shallow clone or merge all data from an object or an array.

  It's very useful in this scenario (or when we need to update just one or few object's props) since I can avoid to manually set all properties to their previous values:

  <W.Code techs={['react', 'js']}>
  ```js
  ❌ { users: state.users error: state.error, pending: true }
  ```
  </W.Code>
  
</W.Hint>

<W.Hint title="useState with function">
  Why do I pass a function to `useState`:

  <W.Code techs={['react', 'js']}>
  ```js
    ✅ setData((s) => ({ ...s, pending: true }));
  ```
  </W.Code>

  instead to simply use the state reference?

    <W.Code techs={['react', 'js']}>
    ```js
    ❌ setData({ ...data, pending: true });
    ```
    </W.Code>

  The `useState` hook returns a function that receives the current state as parameter. 
  Although it's not really necessary in this example, you should always use this approach when your new state depends from the previous one in order to avoid inconsistent or outdated values.

</W.Hint>

<StackBlitz clickToLoad={false} url="https://stackblitz.com/edit/react-mz8fza?file=src/examples/Demo2UniqueUseState.jsx" client:visible />



# `useReducer`

The `useReducer` hook allow you to create a function that defines how the state should be updated: this function is known as `reducer`.

<W.Hint title="Redux">
  You've probably heard of [Redux](https://redux.js.org/) before, that is a global state manager for React applications, often used in enterprise projects.
  
  Redux is a 3rd party library, but we may also define it as a pattern, based on the concept of reducers. So if you learn how to use the `useReducer` hook you'll also know one of its fundamental concepts.
</W.Hint>

The `useReducer` hook accepts three parameters:

* (required) A reducer function that handle state updates
* (required) The initial state
* (optional) Another way to initialize your state but it's not often used. [Read the doc](https://beta.reactjs.org/reference/react/useReducer) for more info about it.


<W.Code techs={['react', 'js']}>
```typescript
const [state, dispatch] = useReducer(reducerFn, initialState);
```
</W.Code>

It always returns the current `state` and a `dispatch` function that will be useful to notify the reducer when the state should be updated:


<W.Code techs={['react', 'js']}>
```typescript
dispatch('increment')
dispatch('decrement')
dispatch('doSomething')
```
</W.Code>

Although an action can be a simple `string`, by convention it should be an object with a `type` property (the action identifier) and a `payload` (that contains optional parameters you can send with the action):

<W.Code techs={['react', 'js']}>
```typescript

dispatch({ type: 'increment', payload: 10 })            // increment by 10
dispatch({ type: 'decrement', payload: 5 })             // decrement by 5
dispatch({ type: 'doSomething', payload 'anything' })
```
</W.Code>


## How `useReducer` works:

* the state is handled by a (reducer) function 
* the state can be updated only when the `dispatch` is invoked
* the reducer is automatically invoked after every `dispatch`
* the reducer always receives the current state and the `action` object (`{type: ..., payload: ...}`)
* the state can be updated accordingly with the action `type` and its `payload`

### 1. Define the reducer and initialize the state to `0` (zero):

<W.Code techs={['react', 'js']}>
```typescript
const [state, dispatch] = useReducer(myReducer, 0);
```
</W.Code>

### 2. dispatch an action to increment the state by `10`
###
<W.Code techs={['react', 'js']}>
```typescript
dispatch({ type: 'increment', payload: 10 }) 
```
</W.Code>

<W.Code techs={['react', 'js']}>
```typescript
function myReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return state + 1;
    case 'decrement':
      return state - 1;
  }
  // we always must return the current state in case we dispatch 
  // an action that is not handled by the reducer. Otherwise you'll lose the state value.
  return state;
}
```
</W.Code>


# move to "useReducer"

Finally we can migrate our previous code to use the `useReducer` hook:

<W.Code techs={['react', 'js']}>
```typescript
import axios from 'axios';
import React, { useEffect, useReducer } from 'react';

// state initialization
const initialState = { users: [], pending: false, error: false };

// NEW: the reducer function
function demoReducer(state, action) {
  // check the action type
  switch (action.type) {
    case 'setPending':
      // set the pending state to true
      return { ...state, pending: true };

    case 'setError':
      // set the error state to true and remove pending
      return { ...state, error: true, pending: false };
    
    case 'loadUsers':
      // store the payload into the state and remove pending
      return { ...state, users: action.payload, pending: false };

    case 'deleteUser':
      // remove the element that has the ID we have sent as payload from the array
      return {
        users: state.users.filter((u) => u.id !== action.payload),
        error: false,
        pending: false,
      };
    
  }
  return state;
}

export const Demo3UseReducer = () => {
  // NEW: set the reducer and initial state
  const [data, dispatch] = useReducer(demoReducer, initialState);

  useEffect(() => {
    // NEW: dispatch the pending action
    dispatch({ type: 'setPending' });
    axios
      .get('https://jsonplaceholder.typicode.com/users')
      // NEW: dispatch load users to store all received data into the state
      .then((res) => dispatch({ type: 'loadUsers', payload: res.data }))
      // NEW: dispatch the error action
      .catch(() => dispatch({ type: 'setError' }));
  }, []);

  function deleteHandler(id) {
    dispatch({ type: 'setPending' });
    axios
      .delete(`https://jsonplaceholder.typicode.com/users/${id}`)
      .then(() => dispatch({ type: 'deleteUser', payload: id }))
      .catch(() => dispatch({ type: 'setError' }));
  }

  return (
    <div>
      <h1>3. Unique useState Demo</h1>

      {data.pending && <div>loading...</div>}
      {data.error && <div>some errors</div>}

      <ul>
        {data.users.map((u) => (
          <li key={u.id}>
            {u.name}
            <button onClick={() => deleteHandler(u.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

```
</W.Code>



<StackBlitz clickToLoad={false} url="https://stackblitz.com/edit/react-mz8fza?file=src/examples/Demo3UseReducer.jsx" client:visible />

# "useReducer" and TypeScript

As I said, I have created this article as introduction to the next one:

[React 18.x & TypeScript | How to safely type the useReducer hook](./how-to-safely-type-usereducer-in-react-and-typescript)

I really highly recommend to read it if you're using TypeScript!


<W.PostSeries frontmatter={frontmatter} />




<W.Notes>
Snippet to create the https://codetoimg.com/ screenshot used in the recorded video

```ts
axios.get('/api/users')
  .then((res) => {
    setUsers(res.data); 
    setPending(false);  
    setError(false);    
  })
  .catch((e) => {
    setError(true);     
    setPending(false);  
  });
```


```ts
axios.get('https://jsonplaceholder.typicode.com/users')
  .then((res) => dispatch({ type: 'loadUsers', payload: res.data }))
  .catch(() => dispatch({ type: 'setError' }));
```

```
  const [data, dispatch] = useReducer(myReducer, initialState);
```


```
function myReducer(state, action) {
  switch (action.type) {
    case 'loadUsers':
      return { ...state, users: action.payload, pending: false };

    case 'setPending':
      return { ...state, pending: true };

    case 'setError':
      return { ...state, error: true, pending: false };
    
    // ...
    
  }
  return state;
}

```
</W.Notes>
